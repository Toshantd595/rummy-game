<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Love Themed Gin Rummy Multiplayer</title>
<style>
  /* Basic love-themed styling */
  body {
    background: linear-gradient(135deg, #fceabb, #f8b500);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: #800000;
    margin: 0; padding: 0;
    min-height: 100vh;
    display: flex; flex-direction: column; align-items: center;
  }
  header {
    background: #ff4d6d;
    width: 100%;
    padding: 1rem;
    text-align: center;
    color: white;
    font-size: 2rem;
    font-weight: bold;
    font-family: 'Cursive', cursive;
    box-shadow: 0 4px 6px rgba(0,0,0,0.2);
  }
  #lobby, #game {
    margin-top: 1rem;
    width: 90vw;
    max-width: 900px;
    background: white;
    border-radius: 15px;
    box-shadow: 0 8px 15px rgba(0,0,0,0.3);
    padding: 1rem;
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }
  #player-hand, #opponent-hand, #melds {
    display: flex;
    gap: 0.5rem;
    overflow-x: auto;
    padding: 0.5rem;
    border: 1px solid #f8b500;
    border-radius: 10px;
    background: #fff0f0;
  }
  .card {
    width: 60px;
    height: 90px;
    border-radius: 8px;
    background: white;
    box-shadow: 0 2px 5px rgba(0,0,0,0.15);
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    padding: 5px;
    cursor: pointer;
    user-select: none;
    font-weight: bold;
    font-size: 1.2rem;
    color: #800000;
    position: relative;
  }
  .card.red {
    color: #d22;
  }
  .card .top-left, .card .bottom-right {
    font-size: 1rem;
  }
  .card .suit {
    font-size: 1.5rem;
    text-align: center;
  }
  .card.selected {
    outline: 3px solid #ff4d6d;
    outline-offset: -3px;
  }
  #deck, #discard {
    width: 70px;
    height: 100px;
    border-radius: 10px;
    background: #f8b500;
    box-shadow: inset 0 0 10px #fff;
    display: flex;
    justify-content: center;
    align-items: center;
    font-weight: bold;
    font-size: 1.2rem;
    color: #800000;
    cursor: pointer;
    user-select: none;
  }
  #controls {
    display: flex;
    gap: 1rem;
    justify-content: center;
    flex-wrap: wrap;
  }
  button {
    background: #ff4d6d;
    border: none;
    color: white;
    padding: 0.7rem 1.2rem;
    font-size: 1rem;
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 3px 6px rgba(0,0,0,0.2);
    transition: background 0.3s ease;
  }
  button:hover:not(:disabled) {
    background: #d43a58;
  }
  button:disabled {
    background: #ffa3b1;
    cursor: not-allowed;
  }
  #messages {
    min-height: 2rem;
    font-weight: bold;
    text-align: center;
  }
  #scoreboard {
    display: flex;
    justify-content: space-around;
    font-size: 1.1rem;
    font-weight: bold;
  }
  /* Love theme hearts */
  .heart {
    color: #ff4d6d;
    font-size: 1.2rem;
    margin-left: 0.3rem;
  }
  #melds {
    flex-wrap: wrap;
  }
  #melds strong {
    width: 100%;
    margin-bottom: 0.3rem;
  }
  #room-info {
    font-weight: bold;
    text-align: center;
  }
  #lobby input, #lobby button {
    font-size: 1rem;
    padding: 0.5rem;
  }
  #meld-selection {
    margin-top: 0.5rem;
    font-size: 0.9rem;
    color: #800000;
  }
</style>
</head>
<body>

<header>❤️ Love Themed Gin Rummy Multiplayer ❤️</header>

<div id="lobby">
  <h2>Create or Join Room</h2>
  <input type="text" id="room-id-input" placeholder="Enter Room ID (e.g. ABC123)" maxlength="6" style="text-transform: uppercase;" />
  <button id="btn-join-room">Join Room</button>
  <button id="btn-create-room">Create Room</button>
  <div id="lobby-message" style="margin-top: 1rem; font-weight: bold; color: #800000;"></div>
</div>

<div id="game" style="display:none;">
  <div id="room-info">Room: <span id="room-id-display"></span></div>
  <div id="scoreboard">
    <div>You: <span id="player-score">0</span> <span class="heart">♥</span></div>
    <div>Opponent: <span id="opponent-score">0</span> <span class="heart">♥</span></div>
  </div>

  <div>
    <strong>Opponent's Hand</strong>
    <div id="opponent-hand"></div>
  </div>

  <div style="display:flex; justify-content:center; gap: 1rem; margin: 1rem 0;">
    <div>
      <div id="deck" title="Draw Pile">Deck</div>
      <small>Draw Pile</small>
    </div>
    <div>
      <div id="discard" title="Discard Pile">Discard</div>
      <small>Discard Pile</small>
    </div>
  </div>

  <div>
    <strong>Your Hand</strong>
    <div id="player-hand"></div>
  </div>

  <div id="melds">
    <strong>Your Melds (Click cards to select/deselect for meld):</strong>
    <div id="meld-selection"></div>
    <button id="btn-create-meld" disabled>Create Meld</button>
    <div id="your-melds-list" style="margin-top: 0.5rem;"></div>
  </div>

  <div id="controls">
    <button id="btn-draw" disabled>Draw Card</button>
    <button id="btn-knock" disabled>Knock</button>
    <button id="btn-gin" disabled>Go Gin</button>
    <button id="btn-discard" disabled>Discard Selected Card</button>
    <button id="btn-leave-room" style="background:#800000;">Leave Room</button>
  </div>

  <div id="messages"></div>
</div>

<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>

<script>
  // Initialize Firebase
  const firebaseConfig = {
    apiKey: "AIzaSyC1D45vfziD-wqIrDGANAY7GzR0L94BqB8",
    authDomain: "rummy-multiplayer-fe391.firebaseapp.com",
    databaseURL: "https://rummy-multiplayer-fe391-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "rummy-multiplayer-fe391",
    storageBucket: "rummy-multiplayer-fe391.firebasestorage.app",
    messagingSenderId: "717212591323",
    appId: "1:717212591323:web:7cb38b16733f7cb38b16733f7a9b5498fe"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  // Card utilities
  const suits = ['♠', '♥', '♦', '♣'];
  const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
  const cardValues = {
    'A': 1, '2': 2, '3': 3, '4':4, '5':5, '6':6, '7':7, '8':8, '9':9, '10':10,
    'J':10, 'Q':10, 'K':10
  };

  // UI Elements
  const lobbyDiv = document.getElementById('lobby');
  const gameDiv = document.getElementById('game');
  const roomIdInput = document.getElementById('room-id-input');
  const btnJoinRoom = document.getElementById('btn-join-room');
  const btnCreateRoom = document.getElementById('btn-create-room');
  const lobbyMessage = document.getElementById('lobby-message');

  const roomIdDisplay = document.getElementById('room-id-display');
  const playerScoreSpan = document.getElementById('player-score');
  const opponentScoreSpan = document.getElementById('opponent-score');
  const playerHandDiv = document.getElementById('player-hand');
  const opponentHandDiv = document.getElementById('opponent-hand');
  const deckDiv = document.getElementById('deck');
  const discardDiv = document.getElementById('discard');
  const btnDraw = document.getElementById('btn-draw');
  const btnKnock = document.getElementById('btn-knock');
  const btnGin = document.getElementById('btn-gin');
  const btnDiscard = document.getElementById('btn-discard');
  const btnCreateMeld = document.getElementById('btn-create-meld');
  const yourMeldsList = document.getElementById('your-melds-list');
  const meldSelectionDiv = document.getElementById('meld-selection');
  const btnLeaveRoom = document.getElementById('btn-leave-room');
  const messagesDiv = document.getElementById('messages');

  // Game State
  let roomId = null;
  let playerId = null; // "player1" or "player2"
  let gameData = null;
  let selectedCardsForMeld = [];
  let selectedCardToDiscard = null;

  // Firebase references
  let roomRef = null;

  // Helper functions
  function createDeck() {
    const d = [];
    for (const s of suits) {
      for (const r of ranks) {
        d.push({suit: s, rank: r});
      }
    }
    return d;
  }

  function shuffle(array) {
    for (let i = array.length -1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i+1));
      [array[i], array[j]] = [array[j], array[i]];
    }
  }

  function cardToString(card) {
    return card.rank + card.suit;
  }

  function cardEquals(a, b) {
    return a.rank === b.rank && a.suit === b.suit;
  }

  function renderCard(card, options = {}) {
    const {clickable = false, onClick = null, selected = false} = options;
    const cardDiv = document.createElement('div');
    cardDiv.className = 'card';
    if (card.suit === '♥' || card.suit === '♦') cardDiv.classList.add('red');
    if (selected) cardDiv.classList.add('selected');
    cardDiv.innerHTML = `
      <div class="top-left">${card.rank}</div>
      <div class="suit">${card.suit}</div>
      <div class="bottom-right">${card.rank}</div>
    `;
    if (clickable) {
      cardDiv.style.cursor = 'pointer';
      cardDiv.addEventListener('click', () => {
        if (onClick) onClick(card);
      });
    }
    return cardDiv;
  }

  function renderHand(hand, container, options = {}) {
    const {clickable = false, onClick = null, hideCards = false, selectedCards = []} = options;
    container.innerHTML = '';
    hand.forEach(card => {
      if (hideCards) {
        const back = document.createElement('div');
        back.className = 'card';
        back.style.background = '#800000';
        back.style.color = '#f8b500';
        back.style.textAlign = 'center';
        back.style.fontSize = '2rem';
        back.style.userSelect = 'none';
        back.textContent = '♥';
        container.appendChild(back);
      } else {
        const isSelected = selectedCards.some(c => cardEquals(c, card));
        container.appendChild(renderCard(card, {clickable, onClick, selected: isSelected}));
      }
    });
  }

  function updateUI() {
    if (!gameData) return;
    const playerHand = gameData[playerId].hand;
    const opponentId = playerId === 'player1' ? 'player2' : 'player1';
    const opponentHand = gameData[opponentId].hand;
    const playerMelds = gameData[playerId].melds || [];
    const opponentMelds = gameData[opponentId].melds || [];
    const deckSize = gameData.deck.length;
    const discardPile = gameData.discardPile;
    const turn = gameData.turn;
    const scores = gameData.scores || {player1:0, player2:0};
    const roundOver = gameData.roundOver || false;

    roomIdDisplay.textContent = roomId;
    playerScoreSpan.textContent = scores[playerId];
    opponentScoreSpan.textContent = scores[opponentId];

    renderHand(playerHand, playerHandDiv, true, onPlayerCardClick, false, selectedCardsForMeld);
    renderHand(opponentHand, opponentHandDiv, false, null, true);

    deckDiv.textContent = `Deck\n(${deckSize})`;
    discardDiv.textContent = discardPile.length > 0 ? cardToString(discardPile[discardPile.length - 1]) : 'Discard';

    // Melds display
    yourMeldsList.innerHTML = '';
    playerMelds.forEach((meld, idx) => {
      const meldDiv = document.createElement('div');
      meldDiv.style.display = 'inline-flex';
      meldDiv.style.gap = '0.3rem';
      meldDiv.style.marginBottom = '0.3rem';
      meld.forEach(card => {
        meldDiv.appendChild(renderCard(card));
      });
      yourMeldsList.appendChild(meldDiv);
    });

    // Meld selection display
    meldSelectionDiv.textContent = selectedCardsForMeld.length > 0 ? 
      'Selected for meld: ' + selectedCardsForMeld.map(cardToString).join(', ') : 'Select cards in your hand to create a meld';

    // Buttons enabled/disabled logic
    const isPlayerTurn = turn === playerId && !roundOver;
    btnDraw.disabled = !isPlayerTurn || gameData.drawnCard !== null;
    btnKnock.disabled = !isPlayerTurn || gameData.drawnCard === null || roundOver || calculateDeadwood(playerHand, playerMelds) > 10;
    btnGin.disabled = !isPlayerTurn || gameData.drawnCard === null || roundOver || calculateDeadwood(playerHand, playerMelds) !== 0;
    btnDiscard.disabled = !isPlayerTurn || gameData.drawnCard === null || !selectedCardToDiscard || roundOver;
    btnCreateMeld.disabled = !isPlayerTurn || selectedCardsForMeld.length < 3 || !isValidMeld(selectedCardsForMeld) || roundOver;

    messagesDiv.textContent = gameData.message || (roundOver ? 'Round over. Start a new round or leave room.' : (isPlayerTurn ? 'Your turn' : "Opponent's turn"));
  }

  // Meld validation helpers
  function isValidMeld(cards) {
    if (cards.length < 3) return false;
    // Check if all cards same rank (set)
    const allSameRank = cards.every(c => c.rank === cards[0].rank);
    if (allSameRank) return true;

    // Check if run: same suit, consecutive ranks
    const allSameSuit = cards.every(c => c.suit === cards[0].suit);
    if (!allSameSuit) return false;

    // Sort cards by rank index
    const rankIndices = cards.map(c => ranks.indexOf(c.rank)).sort((a,b) => a-b);

    for (let i=1; i<rankIndices.length; i++) {
      if (rankIndices[i] !== rankIndices[i-1] + 1) return false;
    }
    return true;
  }

  // Deadwood calculation: sum of cards not in melds
  function calculateDeadwood(hand, melds) {
    const meldCards = melds.flat();
    const deadwoodCards = hand.filter(card => !meldCards.some(meldCard => cardEquals(card, meldCard)));
    return deadwoodCards.reduce((sum, c) => sum + cardValues[c.rank], 0);
  }

  // Event Handlers
  function onPlayerCardClick(card) {
    if (!gameData) return;
    if (gameData.turn !== playerId) return;
    if (gameData.drawnCard === null) {
      messagesDiv.textContent = 'You must draw a card first.';
      return;
    }

    // If selecting for meld creation mode
    if (selectedCardToDiscard && cardEquals(card, selectedCardToDiscard)) {
      // Cannot select discard card for meld
      messagesDiv.textContent = 'Cannot select the card you want to discard for meld.';
      return;
    }

    // Toggle selection for meld
    const idx = selectedCardsForMeld.findIndex(c => cardEquals(c, card));
    if (idx >= 0) {
      selectedCardsForMeld.splice(idx, 1);
    } else {
      selectedCardsForMeld.push(card);
    }
    updateUI();
  }

  function onPlayerHandClick(card) {
    // For discard selection
    if (!gameData) return;
    if (gameData.turn !== playerId) return;
    if (gameData.drawnCard === null) {
      messagesDiv.textContent = 'You must draw a card first.';
      return;
    }
    // Select card to discard
    selectedCardToDiscard = card;
    // Clear meld selection if discard selected
    selectedCardsForMeld = [];
    updateUI();
  }

  // Draw card from deck or discard pile
  function drawCard(fromDiscard) {
    if (!gameData) return;
    if (gameData.turn !== playerId) return;
    if (gameData.drawnCard !== null) return;

    if (fromDiscard && gameData.discardPile.length === 0) {
      messagesDiv.textContent = 'Discard pile is empty.';
      return;
    }
    if (!fromDiscard && gameData.deck.length === 0) {
      messagesDiv.textContent = 'Deck is empty. Round ends.';
      endRound();
      return;
    }

    // Update gameData in Firebase
    const card = fromDiscard ? gameData.discardPile[gameData.discardPile.length - 1] : gameData.deck[gameData.deck.length - 1];
    const updates = {};
    if (fromDiscard) {
      updates[`/rooms/${roomId}/discardPile`] = gameData.discardPile.slice(0, -1);
    } else {
      updates[`/rooms/${roomId}/deck`] = gameData.deck.slice(0, -1);
    }
    updates[`/rooms/${roomId}/${playerId}/hand`] = [...gameData[playerId].hand, card];
    updates[`/rooms/${roomId}/drawnCard`] = card;
    updates[`/rooms/${roomId}/message`] = `Player ${playerId === 'player1' ? '1' : '2'} drew a card. Discard a card.`;
    db.ref().update(updates);
  }

  // Discard selected card
  function discardSelectedCard() {
    if (!gameData) return;
    if (gameData.turn !== playerId) return;
    if (gameData.drawnCard === null) {
      messagesDiv.textContent = 'You must draw a card first.';
      return;
    }
    if (!selectedCardToDiscard) {
      messagesDiv.textContent = 'Select a card to discard.';
      return;
    }

    // Remove card from hand
    const hand = [...gameData[playerId].hand];
    const idx = hand.findIndex(c => cardEquals(c, selectedCardToDiscard));
    if (idx === -1) {
      messagesDiv.textContent = 'Selected card not in hand.';
      return;
    }
    hand.splice(idx, 1);

    // Update discard pile and turn
    const opponentId = playerId === 'player1' ? 'player2' : 'player1';
    const updates = {};
    updates[`/rooms/${roomId}/${playerId}/hand`] = hand;
    updates[`/rooms/${roomId}/discardPile`] = [...gameData.discardPile, selectedCardToDiscard];
    updates[`/rooms/${roomId}/drawnCard`] = null;
    updates[`/rooms/${roomId}/turn`] = opponentId;
    updates[`/rooms/${roomId}/message`] = `Player ${playerId === 'player1' ? '1' : '2'} discarded ${cardToString(selectedCardToDiscard)}. Opponent's turn.`;
    updates[`/rooms/${roomId}/meldSelection`] = null;
    updates[`/rooms/${roomId}/selectedCardToDiscard`] = null;
    db.ref().update(updates);
    selectedCardToDiscard = null;
    selectedCardsForMeld = [];
  }

  // Create meld from selected cards
  function createMeld() {
    if (!gameData) return;
    if (gameData.turn !== playerId) return;
    if (selectedCardsForMeld.length < 3) {
      messagesDiv.textContent = 'Select at least 3 cards for a meld.';
      return;
    }
    if (!isValidMeld(selectedCardsForMeld)) {
      messagesDiv.textContent = 'Selected cards do not form a valid meld.';
      return;
    }

    // Remove meld cards from hand and add to melds
    const hand = [...gameData[playerId].hand];
    for (const c of selectedCardsForMeld) {
      const idx = hand.findIndex(card => cardEquals(card, c));
      if (idx === -1) {
        messagesDiv.textContent = 'One or more selected cards not in hand.';
        return;
      }
      hand.splice(idx, 1);
    }
    const melds = gameData[playerId].melds || [];
    melds.push(selectedCardsForMeld);

    // Update Firebase
    const updates = {};
    updates[`/rooms/${roomId}/${playerId}/hand`] = hand;
    updates[`/rooms/${roomId}/${playerId}/melds`] = melds;
    updates[`/rooms/${roomId}/message`] = `Player ${playerId === 'player1' ? '1' : '2'} created a meld.`;
    updates[`/rooms/${roomId}/meldSelection`] = null;
    db.ref().update(updates);

    selectedCardsForMeld = [];
    updateUI();
  }

  // Knock
  function knock() {
    if (!gameData) return;
    if (gameData.turn !== playerId) return;
    if (gameData.drawnCard === null) {
      messagesDiv.textContent = 'You must draw a card first.';
      return;
    }
    const deadwood = calculateDeadwood(gameData[playerId].hand, gameData[playerId].melds || []);
    if (deadwood > 10) {
      messagesDiv.textContent = 'Cannot knock with deadwood > 10.';
      return;
    }

    // End round, calculate scores
    endRound(playerId, false);
  }

  // Go Gin
  function goGin() {
    if (!gameData) return;
    if (gameData.turn !== playerId) return;
    if (gameData.drawnCard === null) {
      messagesDiv.textContent = 'You must draw a card first.';
      return;
    }
    const deadwood = calculateDeadwood(gameData[playerId].hand, gameData[playerId].melds || []);
    if (deadwood !== 0) {
      messagesDiv.textContent = 'You can only go Gin with zero deadwood.';
      return;
    }

    endRound(playerId, true);
  }

  // End round and calculate scores
  function endRound(knockerId = null, gin = false) {
    if (!gameData) return;
    const opponentId = playerId === 'player1' ? 'player2' : 'player1';

    // Calculate deadwood
    const p1Deadwood = calculateDeadwood(gameData.player1.hand, gameData.player1.melds || []);
    const p2Deadwood = calculateDeadwood(gameData.player2.hand, gameData.player2.melds || []);

    let scores = {...gameData.scores};
    let message = '';

    if (gin && knockerId) {
      // Gin bonus 25 + opponent deadwood
      const opponentDeadwood = knockerId === 'player1' ? p2Deadwood : p1Deadwood;
      scores[knockerId] += 25 + opponentDeadwood;
      message = `Player ${knockerId === 'player1' ? '1' : '2'} went Gin! Gains ${25 + opponentDeadwood} points.`;
    } else if (knockerId) {
      // Knock scoring
      const knockerDeadwood = knockerId === 'player1' ? p1Deadwood : p2Deadwood;
      const otherDeadwood = knockerId === 'player1' ? p2Deadwood : p1Deadwood;

      if (knockerDeadwood < otherDeadwood) {
        scores[knockerId] += otherDeadwood - knockerDeadwood;
        message = `Player ${knockerId === 'player1' ? '1' : '2'} knocked and wins ${otherDeadwood - knockerDeadwood} points.`;
      } else {
        // Undercut bonus 10 + difference to opponent
        const undercutPlayer = knockerId === 'player1' ? 'player2' : 'player1';
        scores[undercutPlayer] += 10 + knockerDeadwood - otherDeadwood;
        message = `Player ${knockerId === 'player1' ? '1' : '2'} was undercut! Opponent gains ${10 + knockerDeadwood - otherDeadwood} points.`;
      }
    } else {
      message = 'Round ended with no knock or Gin.';
    }

    // Reset round state: new deck, hands, melds, discard, drawnCard, turn player1
    let newDeck = createDeck();
    shuffle(newDeck);

    const p1Hand = [];
    const p2Hand = [];
    for (let i=0; i<10; i++) {
      p1Hand.push(newDeck.pop());
      p2Hand.push(newDeck.pop());
    }
    const newDiscardPile = [newDeck.pop()];

    const updates = {
      [`/rooms/${roomId}/deck`]: newDeck,
      [`/rooms/${roomId}/discardPile`]: newDiscardPile,
      [`/rooms/${roomId}/player1/hand`]: p1Hand,
      [`/rooms/${roomId}/player2/hand`]: p2Hand,
      [`/rooms/${roomId}/player1/melds`]: [],
      [`/rooms/${roomId}/player2/melds`]: [],
      [`/rooms/${roomId}/turn`]: 'player1',
      [`/rooms/${roomId}/drawnCard`]: null,
      [`/rooms/${roomId}/scores`]: scores,
      [`/rooms/${roomId}/roundOver`]: false,
      [`/rooms/${roomId}/message`]: message,
      [`/rooms/${roomId}/meldSelection`]: null,
      [`/rooms/${roomId}/selectedCardToDiscard`]: null,
    };
    db.ref().update(updates);
  }

  // Generate random room ID (6 uppercase letters)
  function generateRoomId() {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    let id = '';
    for (let i=0; i<6; i++) {
      id += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return id;
  }

  // Create room
  async function createRoom() {
    roomId = generateRoomId();
    playerId = 'player1';

    // Initialize game state
    const deck = createDeck();
    shuffle(deck);
    const player1Hand = [];
    const player2Hand = [];
    for (let i=0; i<10; i++) {
      player1Hand.push(deck.pop());
      player2Hand.push(deck.pop());
    }
    const discardPile = [deck.pop()];

    const roomData = {
      deck,
      discardPile,
      player1: {
        hand: player1Hand,
        melds: [],
      },
      player2: {
        hand: player2Hand,
        melds: [],
      },
      turn: 'player1',
      drawnCard: null,
      scores: {player1: 0, player2: 0},
      roundOver: false,
      message: 'Waiting for opponent to join...',
      meldSelection: null,
      selectedCardToDiscard: null,
      players: {
        player1: true,
        player2: false,
      }
    };

    await db.ref(`/rooms/${roomId}`).set(roomData);
    lobbyMessage.textContent = `Room created: ${roomId}. Waiting for player 2 to join. Share this ID.`;
    listenToRoom();
    showGameUI();
  }

  // Join room
  async function joinRoom(id) {
    if (!id || id.length !== 6) {
      lobbyMessage.textContent = 'Invalid room ID.';
      return;
    }
    id = id.toUpperCase();
    const roomSnap = await db.ref(`/rooms/${id}`).get();
    if (!roomSnap.exists()) {
      lobbyMessage.textContent = 'Room not found.';
      return;
    }
    const room = roomSnap.val();
    if (room.players.player2) {
      lobbyMessage.textContent = 'Room is full.';
      return;
    }
    roomId = id;
    playerId = 'player2';

    // Mark player2 as joined
    await db.ref(`/rooms/${roomId}/players/player2`).set(true);
    // Update message to start game if player1 is ready
    await db.ref(`/rooms/${roomId}/message`).set('Both players joined. Player 1 starts.');

    listenToRoom();
    showGameUI();
  }

  // Listen to room changes
  function listenToRoom() {
    if (!roomId) return;
    if (roomRef) roomRef.off();
    roomRef = db.ref(`/rooms/${roomId}`);
    roomRef.on('value', (snapshot) => {
      const data = snapshot.val();
      if (!data) {
        messagesDiv.textContent = 'Room closed.';
        resetToLobby();
        return;
      }
      gameData = data;

      // Check if both players joined
      if (!data.players.player1 || !data.players.player2) {
        messagesDiv.textContent = 'Waiting for opponent to join...';
      } else {
        messagesDiv.textContent = data.message || '';
      }

      updateUI();
    });
  }

  // Show game UI and hide lobby
  function showGameUI() {
    lobbyDiv.style.display = 'none';
    gameDiv.style.display = 'flex';
  }

  // Reset to lobby UI
  function resetToLobby() {
    lobbyDiv.style.display = 'flex';
    gameDiv.style.display = 'none';
    roomId = null;
    playerId = null;
    gameData = null;
    selectedCardsForMeld = [];
    selectedCardToDiscard = null;
    lobbyMessage.textContent = '';
    roomIdInput.value = '';
  }

  // Leave room
  async function leaveRoom() {
    if (!roomId || !playerId) return;
    // Remove player from room
    await db.ref(`/rooms/${roomId}/players/${playerId}`).remove();

    // If no players left, delete room
    const roomSnap = await db.ref(`/rooms/${roomId}/players`).get();
    if (!roomSnap.exists()) {
      await db.ref(`/rooms/${roomId}`).remove();
    }
    resetToLobby();
  }

  // UI Event Listeners
  btnCreateRoom.addEventListener('click', () => {
    createRoom();
  });
  btnJoinRoom.addEventListener('click', () => {
    joinRoom(roomIdInput.value);
  });
  deckDiv.addEventListener('click', () => {
    if (gameData && gameData.turn === playerId && gameData.drawnCard === null && !gameData.roundOver) {
      drawCard(false);
    }
  });
  discardDiv.addEventListener('click', () => {
    if (gameData && gameData.turn === playerId && gameData.drawnCard === null && !gameData.roundOver) {
      drawCard(true);
    }
  });
  btnDraw.addEventListener('click', () => {
    if (gameData && gameData.turn === playerId && gameData.drawnCard === null && !gameData.roundOver) {
      drawCard(false);
    }
  });
  btnDiscard.addEventListener('click', () => {
    discardSelectedCard();
  });
  btnCreateMeld.addEventListener('click', () => {
    createMeld();
  });
  btnKnock.addEventListener('click', () => {
    knock();
  });
  btnGin.addEventListener('click', () => {
    goGin();
  });
  btnLeaveRoom.addEventListener('click', () => {
    leaveRoom();
  });

  // Player hand card click for discard selection and meld selection
playerHandDiv.addEventListener('click', (e) => {
  if (!gameData || gameData.turn !== playerId || gameData.roundOver) return;

  const cardDiv = e.target.closest('.card');
  if (!cardDiv) return;

  const index = Array.from(playerHandDiv.children).indexOf(cardDiv);
  if (index === -1) return;
  const card = gameData[playerId].hand[index];

  // Ensure player has drawn a card before interacting
  if (gameData.drawnCard === null) {
    messagesDiv.textContent = 'You must draw a card first.';
    return;
  }

  // If discard button is active and no meld is being formed
  if (!btnDiscard.disabled && selectedCardsForMeld.length === 0) {
    // If the clicked card is already selected for discard, deselect it
    if (selectedCardToDiscard && cardEquals(card, selectedCardToDiscard)) {
      selectedCardToDiscard = null;
    } else {
      selectedCardToDiscard = card;
    }
    updateUI();
    return;
  }

  // Otherwise handle meld selection
  const idx = selectedCardsForMeld.findIndex(c => cardEquals(c, card));
  if (idx >= 0) {
    selectedCardsForMeld.splice(idx, 1);
  } else {
    // Prevent selecting card marked for discard
    if (selectedCardToDiscard && cardEquals(card, selectedCardToDiscard)) {
      messagesDiv.textContent = 'Cannot select the card you want to discard for meld.';
      return;
    }
    selectedCardsForMeld.push(card);
  }

  updateUI();
});


  // On page load show lobby
  resetToLobby();

</script>

</body>
</html>
