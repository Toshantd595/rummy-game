<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>‚ù§Ô∏è Love Themed Gin Rummy Multiplayer ‚ù§Ô∏è</title>
<style>
  /* Reset & base */
  * {
    box-sizing: border-box;
  }
  body, html {
    margin: 0; padding: 0;
    height: 100%;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #fceabb, #f8b500);
    color: #800000;
    display: flex;
    flex-direction: column;
    align-items: center;
    overflow: hidden;
  }
  header {
    background: #ff4d6d;
    width: 100%;
    padding: 1rem 0.5rem;
    text-align: center;
    color: white;
    font-size: 1.8rem;
    font-family: 'Cursive', cursive;
    font-weight: bold;
    box-shadow: 0 4px 6px rgba(0,0,0,0.2);
    flex-shrink: 0;
  }
  #app {
    flex: 1 1 auto;
    width: 100vw;
    max-width: 900px;
    display: flex;
    flex-direction: column;
    background: white;
    border-radius: 15px;
    margin: 0.5rem;
    box-shadow: 0 8px 15px rgba(0,0,0,0.3);
    overflow: hidden;
  }
  /* Lobby */
  #lobby {
    padding: 1rem;
    display: flex;
    flex-direction: column;
    gap: 0.7rem;
    align-items: center;
  }
  #lobby input {
    font-size: 1rem;
    padding: 0.5rem;
    width: 60%;
    max-width: 250px;
    border: 2px solid #ff4d6d;
    border-radius: 8px;
    text-transform: uppercase;
    text-align: center;
    color: #800000;
  }
  #lobby button {
    background: #ff4d6d;
    border: none;
    color: white;
    padding: 0.7rem 1.2rem;
    font-size: 1rem;
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 3px 6px rgba(0,0,0,0.2);
    transition: background 0.3s ease;
    width: 45%;
    max-width: 150px;
  }
  #lobby button:hover:not(:disabled) {
    background: #d43a58;
  }
  #lobby-message {
    margin-top: 0.5rem;
    font-weight: bold;
    color: #800000;
    text-align: center;
  }
  /* Game layout */
  #game {
    flex: 1 1 auto;
    display: flex;
    flex-direction: column;
    height: 100%;
    overflow: hidden;
  }
  #room-info {
    font-weight: bold;
    text-align: center;
    padding: 0.5rem;
    border-bottom: 1px solid #ff4d6d;
    background: #ffe2e7;
    color: #800000;
    flex-shrink: 0;
  }
  #scoreboard {
    display: flex;
    justify-content: space-around;
    font-size: 1.1rem;
    font-weight: bold;
    padding: 0.5rem 1rem;
    background: #fff0f0;
    border-bottom: 1px solid #ff4d6d;
    flex-shrink: 0;
  }
  #scoreboard div {
    display: flex;
    align-items: center;
  }
  .heart {
    color: #ff4d6d;
    font-size: 1.2rem;
    margin-left: 0.3rem;
  }
  /* Main board and chat container */
  #main-container {
    flex: 1 1 auto;
    display: flex;
    gap: 0.5rem;
    padding: 0.5rem 1rem;
    overflow: hidden;
  }
  /* Cards and controls area */
  #board {
    flex: 2 1 0;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    overflow: hidden;
  }
  /* Opponent hand */
  #opponent-hand-container {
    flex-shrink: 0;
  }
  #opponent-hand {
    display: flex;
    gap: 0.3rem;
    overflow-x: auto;
    padding: 0.3rem;
    border: 1px solid #f8b500;
    border-radius: 10px;
    background: #fff0f0;
    user-select: none;
  }
  /* Cards */
  .card {
    width: 48px;
    height: 72px;
    border-radius: 8px;
    background: white;
    box-shadow: 0 2px 5px rgba(0,0,0,0.15);
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    padding: 4px 3px 3px 4px;
    cursor: pointer;
    user-select: none;
    font-weight: bold;
    font-size: 1rem;
    color: #800000;
    position: relative;
    flex-shrink: 0;
  }
  .card.red {
    color: #d22;
  }
  .card .top-left, .card .bottom-right {
    font-size: 0.8rem;
  }
  .card .suit {
    font-size: 1.1rem;
    text-align: center;
  }
  .card.selected {
    outline: 3px solid #ff4d6d;
    outline-offset: -3px;
  }
  /* Player hand */
  #player-hand {
    display: flex;
    gap: 0.3rem;
    overflow-x: auto;
    padding: 0.3rem;
    border: 1px solid #f8b500;
    border-radius: 10px;
    background: #fff0f0;
  }
  /* Deck and discard */
  #deck-discard {
    display: flex;
    gap: 0.5rem;
    justify-content: center;
    margin: 0.3rem 0;
  }
  #deck, #discard {
    width: 55px;
    height: 80px;
    border-radius: 10px;
    background: #f8b500;
    box-shadow: inset 0 0 10px #fff;
    display: flex;
    justify-content: center;
    align-items: center;
    font-weight: bold;
    font-size: 1rem;
    color: #800000;
    cursor: pointer;
    user-select: none;
    flex-shrink: 0;
    white-space: pre-line;
    text-align: center;
    line-height: 1.2rem;
  }
  #melds {
    flex-shrink: 0;
    padding: 0.3rem;
    border: 1px solid #f8b500;
    border-radius: 10px;
    background: #fff0f0;
    overflow-x: auto;
    display: flex;
    gap: 0.5rem;
  }
  #melds strong {
    width: 100%;
    margin-bottom: 0.3rem;
    font-size: 0.95rem;
  }
  #your-melds-list {
    display: flex;
    gap: 0.3rem;
  }
  /* Controls */
  #controls {
    display: flex;
    gap: 0.4rem;
    justify-content: center;
    flex-wrap: wrap;
    padding: 0.3rem 0;
    flex-shrink: 0;
  }
  #controls button {
    background: #ff4d6d;
    border: none;
    color: white;
    padding: 0.5rem 0.9rem;
    font-size: 0.9rem;
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 3px 6px rgba(0,0,0,0.2);
    transition: background 0.3s ease;
    flex: 1 1 120px;
    max-width: 140px;
  }
  #controls button:hover:not(:disabled) {
    background: #d43a58;
  }
  #controls button:disabled {
    background: #ffa3b1;
    cursor: not-allowed;
  }
  #btn-leave-room {
    background: #800000 !important;
    max-width: 100px;
  }
  /* Messages */
  #messages {
    min-height: 1.6rem;
    font-weight: bold;
    text-align: center;
    padding: 0 0.5rem;
    flex-shrink: 0;
    font-size: 0.9rem;
  }
  /* Chat container */
  #chat-container {
    flex: 1 1 250px;
    border-left: 1px solid #ff4d6d;
    display: flex;
    flex-direction: column;
    background: #fff0f0;
    border-radius: 10px;
    overflow: hidden;
  }
  #chat-messages {
    flex: 1 1 auto;
    padding: 0.5rem;
    overflow-y: auto;
    font-size: 0.9rem;
    color: #800000;
  }
  #chat-input-container {
    display: flex;
    gap: 0.3rem;
    padding: 0.3rem 0.5rem;
    border-top: 1px solid #ff4d6d;
    background: #ffe2e7;
  }
  #chat-input {
    flex: 1 1 auto;
    padding: 0.4rem 0.6rem;
    font-size: 1rem;
    border-radius: 6px;
    border: 2px solid #ff4d6d;
    color: #800000;
  }
  #chat-send-btn {
    background: #ff4d6d;
    border: none;
    color: white;
    padding: 0.5rem 0.9rem;
    font-size: 1rem;
    border-radius: 6px;
    cursor: pointer;
    box-shadow: 0 3px 6px rgba(0,0,0,0.2);
    transition: background 0.3s ease;
  }
  #chat-send-btn:hover:not(:disabled) {
    background: #d43a58;
  }
  #chat-send-btn:disabled {
    background: #ffa3b1;
    cursor: not-allowed;
  }
  /* Chat pre-set messages */
  #preset-messages {
    display: flex;
    flex-wrap: wrap;
    gap: 0.3rem;
    padding: 0.3rem 0.5rem;
    border-top: 1px solid #ff4d6d;
    background: #fff0f0;
    font-size: 0.8rem;
    overflow-y: auto;
    max-height: 100px;
  }
  #preset-messages button {
    background: #ff4d6d;
    border: none;
    color: white;
    padding: 0.3rem 0.5rem;
    border-radius: 6px;
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0,0,0,0.15);
    transition: background 0.3s ease;
    flex-shrink: 0;
  }
  #preset-messages button:hover {
    background: #d43a58;
  }
  /* Scrollbar styling */
  #player-hand::-webkit-scrollbar,
  #opponent-hand::-webkit-scrollbar,
  #melds::-webkit-scrollbar,
  #chat-messages::-webkit-scrollbar,
  #preset-messages::-webkit-scrollbar {
    height: 6px;
  }
  #player-hand::-webkit-scrollbar-thumb,
  #opponent-hand::-webkit-scrollbar-thumb,
  #melds::-webkit-scrollbar-thumb,
  #chat-messages::-webkit-scrollbar-thumb,
  #preset-messages::-webkit-scrollbar-thumb {
    background-color: #ff4d6d;
    border-radius: 3px;
  }
  /* Responsive */
  @media (max-width: 600px) {
    #main-container {
      flex-direction: column;
    }
    #chat-container {
      flex: none;
      height: 220px;
      border-left: none;
      border-top: 1px solid #ff4d6d;
      margin-top: 0.5rem;
    }
    #controls button {
      max-width: 100%;
    }
  }
</style>
</head>
<body>

<header>‚ù§Ô∏è Love Themed Gin Rummy Multiplayer ‚ù§Ô∏è</header>

<div id="app">

  <!-- Lobby -->
  <div id="lobby">
    <h2>Create or Join Room</h2>
    <input type="text" id="room-id-input" placeholder="Enter Room ID (e.g. ABC123)" maxlength="6" />
    <div style="display:flex; gap:0.5rem; width: 100%; justify-content: center;">
      <button id="btn-join-room">Join Room</button>
      <button id="btn-create-room">Create Room</button>
    </div>
    <div id="lobby-message"></div>
  </div>

  <!-- Game -->
  <div id="game" style="display:none;">

    <div id="room-info">Room: <span id="room-id-display"></span></div>

    <div id="scoreboard">
      <div>You: <span id="player-score">0</span> <span class="heart">‚ô•</span></div>
      <div>Opponent: <span id="opponent-score">0</span> <span class="heart">‚ô•</span></div>
    </div>

    <div id="main-container">

      <div id="board">

        <div id="opponent-hand-container">
          <strong>Opponent's Hand</strong>
          <div id="opponent-hand" title="Opponent's cards"></div>
        </div>

        <div id="deck-discard">
          <div id="deck" title="Draw Pile">Deck<br>(0)</div>
          <div id="discard" title="Discard Pile">Discard</div>
        </div>

        <div>
          <strong>Your Hand</strong>
          <div id="player-hand" title="Your cards"></div>
        </div>

        <div id="melds">
          <strong>Your Melds (Select cards to create meld):</strong>
          <div id="meld-selection" style="font-size:0.85rem; margin:0.3rem 0; color:#800000;">Select cards in your hand</div>
          <button id="btn-create-meld" disabled>Create Meld</button>
          <div id="your-melds-list"></div>
        </div>

        <div id="controls">
          <button id="btn-draw" disabled>Draw Card</button>
          <button id="btn-knock" disabled>Knock</button>
          <button id="btn-gin" disabled>Go Gin</button>
          <button id="btn-discard" disabled>Discard Selected Card</button>
          <button id="btn-leave-room">Leave Room</button>
        </div>

        <div id="messages"></div>

      </div>

      <div id="chat-container">
        <strong>Chat ‚ù§Ô∏è</strong>
        <div id="chat-messages"></div>
        <div id="preset-messages"></div>
        <div id="chat-input-container">
          <input type="text" id="chat-input" placeholder="Type a message..." />
          <button id="chat-send-btn" disabled>Send</button>
        </div>
      </div>

    </div>

  </div>

</div>

<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>

<script>
  // Initialize Firebase
  const firebaseConfig = {
    apiKey: "AIzaSyC1D45vfziD-wqIrDGANAY7GzR0L94BqB8",
    authDomain: "rummy-multiplayer-fe391.firebaseapp.com",
    databaseURL: "https://rummy-multiplayer-fe391-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "rummy-multiplayer-fe391",
    storageBucket: "rummy-multiplayer-fe391.firebasestorage.app",
    messagingSenderId: "717212591323",
    appId: "1:717212591323:web:7cb38b16733f7cb38b16733f7a9b5498fe"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  // Card utilities
  const suits = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'];
  const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
  const cardValues = {
    'A': 1, '2': 2, '3': 3, '4':4, '5':5, '6':6, '7':7, '8':8, '9':9, '10':10,
    'J':10, 'Q':10, 'K':10
  };

  // UI Elements
  const lobbyDiv = document.getElementById('lobby');
  const gameDiv = document.getElementById('game');
  const roomIdInput = document.getElementById('room-id-input');
  const btnJoinRoom = document.getElementById('btn-join-room');
  const btnCreateRoom = document.getElementById('btn-create-room');
  const lobbyMessage = document.getElementById('lobby-message');

  const roomIdDisplay = document.getElementById('room-id-display');
  const playerScoreSpan = document.getElementById('player-score');
  const opponentScoreSpan = document.getElementById('opponent-score');
  const playerHandDiv = document.getElementById('player-hand');
  const opponentHandDiv = document.getElementById('opponent-hand');
  const deckDiv = document.getElementById('deck');
  const discardDiv = document.getElementById('discard');
  const btnDraw = document.getElementById('btn-draw');
  const btnKnock = document.getElementById('btn-knock');
  const btnGin = document.getElementById('btn-gin');
  const btnDiscard = document.getElementById('btn-discard');
  const btnCreateMeld = document.getElementById('btn-create-meld');
  const yourMeldsList = document.getElementById('your-melds-list');
  const meldSelectionDiv = document.getElementById('meld-selection');
  const btnLeaveRoom = document.getElementById('btn-leave-room');
  const messagesDiv = document.getElementById('messages');

  // Chat Elements
  const chatMessagesDiv = document.getElementById('chat-messages');
  const chatInput = document.getElementById('chat-input');
  const chatSendBtn = document.getElementById('chat-send-btn');
  const presetMessagesDiv = document.getElementById('preset-messages');

  // Game State
  let roomId = null;
  let playerId = null; // "player1" or "player2"
  let gameData = null;
  let selectedCardsForMeld = [];
  let selectedCardToDiscard = null;

  // Firebase references
  let roomRef = null;
  let chatRef = null;

  // Helper functions
  function createDeck() {
    const d = [];
    for (const s of suits) {
      for (const r of ranks) {
        d.push({suit: s, rank: r});
      }
    }
    return d;
  }

  function shuffle(array) {
    for (let i = array.length -1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i+1));
      [array[i], array[j]] = [array[j], array[i]];
    }
  }

  function cardToString(card) {
    return card.rank + card.suit;
  }

  function cardEquals(a, b) {
    return a.rank === b.rank && a.suit === b.suit;
  }

  function renderCard(card, options = {}) {
    const {clickable = false, onClick = null, selected = false} = options;
    const cardDiv = document.createElement('div');
    cardDiv.className = 'card';
    if (card.suit === '‚ô•' || card.suit === '‚ô¶') cardDiv.classList.add('red');
    if (selected) cardDiv.classList.add('selected');
    cardDiv.innerHTML = `
      <div class="top-left">${card.rank}</div>
      <div class="suit">${card.suit}</div>
      <div class="bottom-right">${card.rank}</div>
    `;
    if (clickable) {
      cardDiv.style.cursor = 'pointer';
      cardDiv.addEventListener('click', () => {
        if (onClick) onClick(card);
      });
    }
    return cardDiv;
  }

  function renderHand(hand, container, options = {}) {
    const {clickable = false, onClick = null, hideCards = false, selectedCards = []} = options;
    container.innerHTML = '';
    hand.forEach(card => {
      if (hideCards) {
        const back = document.createElement('div');
        back.className = 'card';
        back.style.background = '#800000';
        back.style.color = '#f8b500';
        back.style.textAlign = 'center';
        back.style.fontSize = '2rem';
        back.style.userSelect = 'none';
        back.textContent = '‚ô•';
        container.appendChild(back);
      } else {
        const isSelected = selectedCards.some(c => cardEquals(c, card));
        container.appendChild(renderCard(card, {clickable, onClick, selected: isSelected}));
      }
    });
  }

  function updateUI() {
    if (!gameData) return;
    const playerHand = gameData[playerId].hand;
    const opponentId = playerId === 'player1' ? 'player2' : 'player1';
    const opponentHand = gameData[opponentId].hand;
    const playerMelds = gameData[playerId].melds || [];
    const opponentMelds = gameData[opponentId].melds || [];
    const deckSize = gameData.deck.length;
    const discardPile = gameData.discardPile;
    const turn = gameData.turn;
    const scores = gameData.scores || {player1:0, player2:0};
    const roundOver = gameData.roundOver || false;

    roomIdDisplay.textContent = roomId;
    playerScoreSpan.textContent = scores[playerId];
    opponentScoreSpan.textContent = scores[opponentId];

    renderHand(playerHand, playerHandDiv, true, onPlayerCardClick, false, selectedCardsForMeld);
    renderHand(opponentHand, opponentHandDiv, false, null, true);

    deckDiv.textContent = `Deck\n(${deckSize})`;
    discardDiv.textContent = discardPile.length > 0 ? cardToString(discardPile[discardPile.length - 1]) : 'Discard';

    // Melds display
    yourMeldsList.innerHTML = '';
    playerMelds.forEach((meld) => {
      const meldDiv = document.createElement('div');
      meldDiv.style.display = 'inline-flex';
      meldDiv.style.gap = '0.2rem';
      meldDiv.style.marginBottom = '0.3rem';
      meld.forEach(card => {
        meldDiv.appendChild(renderCard(card));
      });
      yourMeldsList.appendChild(meldDiv);
    });

    // Meld selection display
    meldSelectionDiv.textContent = selectedCardsForMeld.length > 0 ? 
      'Selected for meld: ' + selectedCardsForMeld.map(cardToString).join(', ') : 'Select cards in your hand to create a meld';

    // Buttons enabled/disabled logic
    const isPlayerTurn = turn === playerId && !roundOver;
    btnDraw.disabled = !isPlayerTurn || gameData.drawnCard !== null;
    btnKnock.disabled = !isPlayerTurn || gameData.drawnCard === null || roundOver || calculateDeadwood(playerHand, playerMelds) > 10;
    btnGin.disabled = !isPlayerTurn || gameData.drawnCard === null || roundOver || calculateDeadwood(playerHand, playerMelds) !== 0;
    btnDiscard.disabled = !isPlayerTurn || gameData.drawnCard === null || !selectedCardToDiscard || roundOver;
    btnCreateMeld.disabled = !isPlayerTurn || selectedCardsForMeld.length < 3 || !isValidMeld(selectedCardsForMeld) || roundOver;

    // Chat send button enable if input nonempty
    chatSendBtn.disabled = chatInput.value.trim().length === 0;

    messagesDiv.textContent = gameData.message || (roundOver ? 'Round over. Start a new round or leave room.' : (isPlayerTurn ? 'Your turn' : "Opponent's turn"));
  }

  // Meld validation helpers
  function isValidMeld(cards) {
    if (cards.length < 3) return false;
    // Check if all cards same rank (set)
    const allSameRank = cards.every(c => c.rank === cards[0].rank);
    if (allSameRank) return true;

    // Check if run: same suit, consecutive ranks
    const allSameSuit = cards.every(c => c.suit === cards[0].suit);
    if (!allSameSuit) return false;

    // Sort cards by rank index
    const rankIndices = cards.map(c => ranks.indexOf(c.rank)).sort((a,b) => a-b);

    for (let i=1; i<rankIndices.length; i++) {
      if (rankIndices[i] !== rankIndices[i-1] + 1) return false;
    }
    return true;
  }

  // Deadwood calculation: sum of cards not in melds
  function calculateDeadwood(hand, melds) {
    const meldCards = melds.flat();
    const deadwoodCards = hand.filter(card => !meldCards.some(meldCard => cardEquals(card, meldCard)));
    return deadwoodCards.reduce((sum, c) => sum + cardValues[c.rank], 0);
  }

  // Draw card from deck or discard pile
  function drawCard(fromDiscard) {
    if (!gameData) return;
    if (gameData.turn !== playerId) return;
    if (gameData.drawnCard !== null) return;

    if (fromDiscard && gameData.discardPile.length === 0) {
      messagesDiv.textContent = 'Discard pile is empty.';
      return;
    }
    if (!fromDiscard && gameData.deck.length === 0) {
      messagesDiv.textContent = 'Deck is empty. Round ends.';
      endRound();
      return;
    }

    // Update gameData in Firebase
    const card = fromDiscard ? gameData.discardPile[gameData.discardPile.length - 1] : gameData.deck[gameData.deck.length - 1];
    const updates = {};
    if (fromDiscard) {
      updates[`/rooms/${roomId}/discardPile`] = gameData.discardPile.slice(0, -1);
    } else {
      updates[`/rooms/${roomId}/deck`] = gameData.deck.slice(0, -1);
    }
    updates[`/rooms/${roomId}/${playerId}/hand`] = [...gameData[playerId].hand, card];
    updates[`/rooms/${roomId}/drawnCard`] = card;
    updates[`/rooms/${roomId}/message`] = `Player ${playerId === 'player1' ? '1' : '2'} drew a card. Select a card to discard.`;
    db.ref().update(updates);

    // Reset discard selection and meld selection
    selectedCardToDiscard = null;
    selectedCardsForMeld = [];
  }

  // Discard selected card
  function discardSelectedCard() {
    if (!gameData) return;
    if (gameData.turn !== playerId) return;
    if (gameData.drawnCard === null) {
      messagesDiv.textContent = 'You must draw a card first.';
      return;
    }
    if (!selectedCardToDiscard) {
      messagesDiv.textContent = 'Please select a card to discard.';
      return;
    }

    // Remove card from hand
    const hand = [...gameData[playerId].hand];
    const idx = hand.findIndex(c => cardEquals(c, selectedCardToDiscard));
    if (idx === -1) {
      messagesDiv.textContent = 'Selected card not in hand.';
      return;
    }
    hand.splice(idx, 1);

    // Update discard pile and turn
    const opponentId = playerId === 'player1' ? 'player2' : 'player1';
    const updates = {};
    updates[`/rooms/${roomId}/${playerId}/hand`] = hand;
    updates[`/rooms/${roomId}/discardPile`] = [...gameData.discardPile, selectedCardToDiscard];
    updates[`/rooms/${roomId}/drawnCard`] = null;
    updates[`/rooms/${roomId}/turn`] = opponentId;
    updates[`/rooms/${roomId}/message`] = `Player ${playerId === 'player1' ? '1' : '2'} discarded ${cardToString(selectedCardToDiscard)}. Opponent's turn.`;
    updates[`/rooms/${roomId}/meldSelection`] = null;
    updates[`/rooms/${roomId}/selectedCardToDiscard`] = null;
    db.ref().update(updates);

    selectedCardToDiscard = null;
    selectedCardsForMeld = [];
  }

  // Create meld from selected cards
  function createMeld() {
    if (!gameData) return;
    if (gameData.turn !== playerId) return;
    if (selectedCardsForMeld.length < 3) {
      messagesDiv.textContent = 'Select at least 3 cards for a meld.';
      return;
    }
    if (!isValidMeld(selectedCardsForMeld)) {
      messagesDiv.textContent = 'Selected cards do not form a valid meld.';
      return;
    }

    // Remove meld cards from hand and add to melds
    const hand = [...gameData[playerId].hand];
    for (const c of selectedCardsForMeld) {
      const idx = hand.findIndex(card => cardEquals(card, c));
      if (idx === -1) {
        messagesDiv.textContent = 'One or more selected cards not in hand.';
        return;
      }
      hand.splice(idx, 1);
    }
    const melds = gameData[playerId].melds || [];
    melds.push(selectedCardsForMeld);

    // Update Firebase
    const updates = {};
    updates[`/rooms/${roomId}/${playerId}/hand`] = hand;
    updates[`/rooms/${roomId}/${playerId}/melds`] = melds;
    updates[`/rooms/${roomId}/message`] = `Player ${playerId === 'player1' ? '1' : '2'} created a meld.`;
    updates[`/rooms/${roomId}/meldSelection`] = null;
    db.ref().update(updates);

    selectedCardsForMeld = [];
    updateUI();
  }

  // Knock
  function knock() {
    if (!gameData) return;
    if (gameData.turn !== playerId) return;
    if (gameData.drawnCard === null) {
      messagesDiv.textContent = 'You must draw a card first.';
      return;
    }
    const deadwood = calculateDeadwood(gameData[playerId].hand, gameData[playerId].melds || []);
    if (deadwood > 10) {
      messagesDiv.textContent = 'Cannot knock with deadwood > 10.';
      return;
    }

    // End round, calculate scores
    endRound(playerId, false);
  }

  // Go Gin
  function goGin() {
    if (!gameData) return;
    if (gameData.turn !== playerId) return;
    if (gameData.drawnCard === null) {
      messagesDiv.textContent = 'You must draw a card first.';
      return;
    }
    const deadwood = calculateDeadwood(gameData[playerId].hand, gameData[playerId].melds || []);
    if (deadwood !== 0) {
      messagesDiv.textContent = 'You can only go Gin with zero deadwood.';
      return;
    }

    endRound(playerId, true);
  }

  // End round and calculate scores
  function endRound(knockerId = null, gin = false) {
    if (!gameData) return;
    const opponentId = playerId === 'player1' ? 'player2' : 'player1';

    // Calculate deadwood
    const p1Deadwood = calculateDeadwood(gameData.player1.hand, gameData.player1.melds || []);
    const p2Deadwood = calculateDeadwood(gameData.player2.hand, gameData.player2.melds || []);

    let scores = {...gameData.scores};
    let message = '';

    if (gin && knockerId) {
      // Gin bonus 25 + opponent deadwood
      const opponentDeadwood = knockerId === 'player1' ? p2Deadwood : p1Deadwood;
      scores[knockerId] += 25 + opponentDeadwood;
      message = `Player ${knockerId === 'player1' ? '1' : '2'} went Gin! Gains ${25 + opponentDeadwood} points.`;
    } else if (knockerId) {
      // Knock scoring
      const knockerDeadwood = knockerId === 'player1' ? p1Deadwood : p2Deadwood;
      const otherDeadwood = knockerId === 'player1' ? p2Deadwood : p1Deadwood;

      if (knockerDeadwood < otherDeadwood) {
        scores[knockerId] += otherDeadwood - knockerDeadwood;
        message = `Player ${knockerId === 'player1' ? '1' : '2'} knocked and wins ${otherDeadwood - knockerDeadwood} points.`;
      } else {
        // Undercut bonus 10 + difference to opponent
        const undercutPlayer = knockerId === 'player1' ? 'player2' : 'player1';
        scores[undercutPlayer] += 10 + knockerDeadwood - otherDeadwood;
        message = `Player ${knockerId === 'player1' ? '1' : '2'} was undercut! Opponent gains ${10 + knockerDeadwood - otherDeadwood} points.`;
      }
    } else {
      message = 'Round ended with no knock or Gin.';
    }

    // Reset round state: new deck, hands, melds, discard, drawnCard, turn player1
    let newDeck = createDeck();
    shuffle(newDeck);

    const p1Hand = [];
    const p2Hand = [];
    for (let i=0; i<10; i++) {
      p1Hand.push(newDeck.pop());
      p2Hand.push(newDeck.pop());
    }
    const newDiscardPile = [newDeck.pop()];

    const updates = {
      [`/rooms/${roomId}/deck`]: newDeck,
      [`/rooms/${roomId}/discardPile`]: newDiscardPile,
      [`/rooms/${roomId}/player1/hand`]: p1Hand,
      [`/rooms/${roomId}/player2/hand`]: p2Hand,
      [`/rooms/${roomId}/player1/melds`]: [],
      [`/rooms/${roomId}/player2/melds`]: [],
      [`/rooms/${roomId}/turn`]: 'player1',
      [`/rooms/${roomId}/drawnCard`]: null,
      [`/rooms/${roomId}/scores`]: scores,
      [`/rooms/${roomId}/roundOver`]: false,
      [`/rooms/${roomId}/message`]: message,
      [`/rooms/${roomId}/meldSelection`]: null,
      [`/rooms/${roomId}/selectedCardToDiscard`]: null,
    };
    db.ref().update(updates);
  }

  // Generate random room ID (6 uppercase letters)
  function generateRoomId() {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    let id = '';
    for (let i=0; i<6; i++) {
      id += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return id;
  }

  // Create room
  async function createRoom() {
    roomId = generateRoomId();
    playerId = 'player1';

    // Initialize game state
    const deck = createDeck();
    shuffle(deck);
    const player1Hand = [];
    const player2Hand = [];
    for (let i=0; i<10; i++) {
      player1Hand.push(deck.pop());
      player2Hand.push(deck.pop());
    }
    const discardPile = [deck.pop()];

    const roomData = {
      deck,
      discardPile,
      player1: {
        hand: player1Hand,
        melds: [],
      },
      player2: {
        hand: player2Hand,
        melds: [],
      },
      turn: 'player1',
      drawnCard: null,
      scores: {player1: 0, player2: 0},
      roundOver: false,
      message: 'Waiting for opponent to join...',
      meldSelection: null,
      selectedCardToDiscard: null,
      players: {
        player1: true,
        player2: false,
      }
    };

    await db.ref(`/rooms/${roomId}`).set(roomData);
    lobbyMessage.textContent = `Room created: ${roomId}. Waiting for player 2 to join. Share this ID.`;
    listenToRoom();
    showGameUI();
    setupChat();
  }

  // Join room
  async function joinRoom(id) {
    if (!id || id.length !== 6) {
      lobbyMessage.textContent = 'Invalid room ID.';
      return;
    }
    id = id.toUpperCase();
    const roomSnap = await db.ref(`/rooms/${id}`).get();
    if (!roomSnap.exists()) {
      lobbyMessage.textContent = 'Room not found.';
      return;
    }
    const room = roomSnap.val();
    if (room.players.player2) {
      lobbyMessage.textContent = 'Room is full.';
      return;
    }
    roomId = id;
    playerId = 'player2';

    // Mark player2 as joined
    await db.ref(`/rooms/${roomId}/players/player2`).set(true);
    // Update message to start game if player1 is ready
    await db.ref(`/rooms/${roomId}/message`).set('Both players joined. Player 1 starts.');

    listenToRoom();
    showGameUI();
    setupChat();
  }

  // Listen to room changes
  function listenToRoom() {
    if (!roomId) return;
    if (roomRef) roomRef.off();
    roomRef = db.ref(`/rooms/${roomId}`);
    roomRef.on('value', (snapshot) => {
      const data = snapshot.val();
      if (!data) {
        messagesDiv.textContent = 'Room closed.';
        resetToLobby();
        return;
      }
      gameData = data;

      // Check if both players joined
      if (!data.players.player1 || !data.players.player2) {
        messagesDiv.textContent = 'Waiting for opponent to join...';
      } else {
        messagesDiv.textContent = data.message || '';
      }

      updateUI();
    });
  }

  // Show game UI and hide lobby
  function showGameUI() {
    lobbyDiv.style.display = 'none';
    gameDiv.style.display = 'flex';
  }

  // Reset to lobby UI
  function resetToLobby() {
    lobbyDiv.style.display = 'flex';
    gameDiv.style.display = 'none';
    roomId = null;
    playerId = null;
    gameData = null;
    selectedCardsForMeld = [];
    selectedCardToDiscard = null;
    lobbyMessage.textContent = '';
    roomIdInput.value = '';
    teardownChat();
  }

  // Leave room
  async function leaveRoom() {
    if (!roomId || !playerId) return;
    // Remove player from room
    await db.ref(`/rooms/${roomId}/players/${playerId}`).remove();

    // If no players left, delete room
    const roomSnap = await db.ref(`/rooms/${roomId}/players`).get();
    if (!roomSnap.exists()) {
      await db.ref(`/rooms/${roomId}`).remove();
    }
    resetToLobby();
  }

  // Player hand card click for discard selection and meld selection
  function onPlayerCardClick(card) {
    if (!gameData || gameData.turn !== playerId || gameData.drawnCard === null || gameData.roundOver) return;

    // If discard button enabled and no meld selection, select card for discard
    if (btnDiscard.disabled === false && selectedCardsForMeld.length === 0) {
      selectedCardToDiscard = card;
      updateUI();
      return;
    }

    // Otherwise toggle meld selection
    const idx = selectedCardsForMeld.findIndex(c => cardEquals(c, card));
    if (idx >= 0) {
      selectedCardsForMeld.splice(idx, 1);
    } else {
      // Prevent selecting card marked for discard
      if (selectedCardToDiscard && cardEquals(card, selectedCardToDiscard)) {
        messagesDiv.textContent = 'Cannot select the card you want to discard for meld.';
        return;
      }
      selectedCardsForMeld.push(card);
    }
    updateUI();
  }

  // Chat functionality
  function setupChat() {
    if (!roomId) return;
    if (chatRef) chatRef.off();

    chatMessagesDiv.innerHTML = '';
    chatInput.value = '';
    chatSendBtn.disabled = true;

    chatRef = db.ref(`/rooms/${roomId}/chat`);
    chatRef.on('child_added', snap => {
      const msg = snap.val();
      if (!msg) return;
      const div = document.createElement('div');
      div.style.marginBottom = '0.3rem';
      div.style.wordBreak = 'break-word';
      div.style.fontSize = '0.9rem';
      div.style.color = msg.sender === playerId ? '#d43a58' : '#800000';
      div.textContent = (msg.sender === playerId ? 'You: ' : 'Opponent: ') + msg.text;
      chatMessagesDiv.appendChild(div);
      chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;
    });

    chatInput.addEventListener('input', () => {
      chatSendBtn.disabled = chatInput.value.trim().length === 0;
    });

    chatSendBtn.onclick = () => {
      const text = chatInput.value.trim();
      if (text.length === 0) return;
      chatRef.push({sender: playerId, text});
      chatInput.value = '';
      chatSendBtn.disabled = true;
    };

    // Flirty preset messages
    const presets = [
      "Hey love, ready to win this game? üòâ",
      "You make my heart race faster than these cards! ‚ù§Ô∏è",
      "Every card I get reminds me of you üòò",
      "Let's shuffle our hearts together üíï",
      "I bet I'll gin before you say 'I love you' again üòÑ",
      "You‚Äôre the queen of my deck üëë",
      "Knock knock... it‚Äôs love at first sight üíñ",
      "Discard your worries, I‚Äôm here üíå",
      "You + Me + Gin Rummy = Perfect night üåô",
      "Playing with you is my favorite game üíò"
    ];
    presetMessagesDiv.innerHTML = '';
    presets.forEach(text => {
      const btn = document.createElement('button');
      btn.textContent = text;
      btn.title = text;
      btn.onclick = () => {
        chatInput.value = text;
        chatSendBtn.disabled = false;
        chatInput.focus();
      };
      presetMessagesDiv.appendChild(btn);
    });
  }

  function teardownChat() {
    if (chatRef) chatRef.off();
    chatMessagesDiv.innerHTML = '';
    chatInput.value = '';
    chatSendBtn.disabled = true;
    presetMessagesDiv.innerHTML = '';
  }

  // UI Event Listeners
  btnCreateRoom.addEventListener('click', () => {
    createRoom();
  });
  btnJoinRoom.addEventListener('click', () => {
    joinRoom(roomIdInput.value);
  });
  deckDiv.addEventListener('click', () => {
    if (gameData && gameData.turn === playerId && gameData.drawnCard === null && !gameData.roundOver) {
      drawCard(false);
    }
  });
  discardDiv.addEventListener('click', () => {
    if (gameData && gameData.turn === playerId && gameData.drawnCard === null && !gameData.roundOver) {
      drawCard(true);
    }
  });
  btnDraw.addEventListener('click', () => {
    if (gameData && gameData.turn === playerId && gameData.drawnCard === null && !gameData.roundOver) {
      drawCard(false);
    }
  });
  btnDiscard.addEventListener('click', () => {
    discardSelectedCard();
  });
  btnCreateMeld.addEventListener('click', () => {
    createMeld();
  });
  btnKnock.addEventListener('click', () => {
    knock();
  });
  btnGin.addEventListener('click', () => {
    goGin();
  });
  btnLeaveRoom.addEventListener('click', () => {
    leaveRoom();
  });

  // Player hand card click handled inside renderCard with onPlayerCardClick

  // On page load show lobby
  resetToLobby();

</script>

</body>
</html>
